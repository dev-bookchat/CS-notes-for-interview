# 디자인 패턴과 프로그래밍 패러다임

## 목차

- [디자인 패턴](#1.-디자인-패턴)
- [프로그래밍 패러다임](#2.-프로그래밍-패러다임)

## 1. 디자인 패턴

- 우리가 프로그래밍을 할 때 사용하는 `React, Vue, Angular` 등 라이브러리나 프레임 워크의 ==기본== 이 되는 **디자인 패턴**에 대해서 알아보자.

**라이브러리**

> 공통으로 사용될 수 있는 특정한 기능을 모듈화한 것을 의미. 파일명 등에 대한 **규칙이 없고**, 프레임워크에 비해 **자유**롭다.

**프레임워크**

> 공통으로 사용될 수 있는 기능들을 모듈화한 것을 의미. 폴더명, 파일명 등에 대한 **규칙이 있고**, 라이브러리에 비해 **엄격**하다.

- **디자인 패턴** 이란, 프로그램을 설계할 때 발생했던 문제점들을 **객체 간의 상호 관계 등을 이용**하여 해결할 수 있도록 하나의 ==규약== 형태로 만들어 놓은 것을 의미한다.

### 1.1.1 싱글톤 패턴

- **싱글톤 패턴**(Singleton pattern) 은 **하나의 클래스**에 오직 **하나의 인스턴스**만 가지는 **패턴**을 의미. 보통 데이터베이스 연결 모듈에 사용.

  하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용. 이 때문에 인스턴스를 생성할 때 드는 비용을 줄일 수 있다. 그러나 하나의 인스턴스에만 의존하기 때문에 의존성이 높아진다는 단점이 있다.

#### 자바스크립트의 싱글톤 패턴

ex) 싱글톤 패턴이 아닐 때

```js
const obj = {
  a: 27,
};

const obj2 = {
  a: 27,
};

console.log(obj === obj2); // false
```

- 앞의 코드에서 볼 수 있듯이 `obj` 와 `obj2` 는 다른 ==인스턴스== 를 가지기 때문에, 동일한 값(true)이 될 수 없다.

ex) 싱글톤 패턴일 때

```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
  getInstance() {
    return this.instance;
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
```

- 앞의 코드는 `Singleton.instance` 라는 ==하나의 인스턴스== 를 가지는 `Singleton` 클래스를 구현한 코드이다. 이를 통해서 `a`와 `b`는 ==하나의 인스턴스==를 가지며, 동일한 값(true)를 가지게 된다.

#### 싱글톤 패턴의 데이터베이스 연결 모듈

- 싱글톤 패턴은 **데이터베이스 연결 모듈**에서 많이 사용된다.

```js
const URL = `https://url.com`;
const createConnection = (url) => ({ url: url });

class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url);
    }
    return DB.instance;
  }
  connect() {
    return this.instance;
  }
}

const a = new DB(URL);
const b = new DB(URL);

console.log(a === b); // true
```

- `DB.instance` 라는 하나의 인스턴스를 기반으로 `a` 와 `b` 를 생성하는 등, 이를 통해서 데이터베이스 연결에 관한 인스턴트 생성 비용을 아낄 수 있는 것이다.

#### mongoose 싱글톤 패턴

- **Node.js** 에서 **MongoDB** 데이터베이스를 연결할 때 사용하는 **mongoose** 모듈에서 싱글톤 패턴을 볼 수 있다.

#### MySQL 의 싱글톤 패턴

- **Node.js** 에서 **MySQL** 데이터베이스를 연결할 때도 싱글톤 패턴을 사용한다. 메인 모듈에서 데이터베이스 연결에 관한 인스턴스를 정의하고, 다른 모듈에서 해당 인스턴스를 기반으로 쿼리를 보내는 형식으로 쓰인다.

#### 싱글톤 패턴의 단점

- 싱글톤 패턴은 **TDD**(Test Driven Development)를 할 때 문제가 된다. TDD를 할 때 **단위 테스트**를 주로 하게 되는데, 이 단위 테스트는 서로 독립적이어야 하고 테스트를 어떤 순서로든 실행할 수 있어야 한다는 조건이 필요하다. 그러나, 싱글톤 패턴은 미리 생성된 **하나의 인스턴스** 를 기반으로 구현하는 패턴이기에 각 테스트마다 **독립적인 인스턴스**를 만들기 어렵다.

#### 의존성 주입

- 싱글톤 패턴은 모듈 간의 결합이 강해질 수 있다는 단점이 있다. 이를 해결하기 위해서는 ==의존성 주입== 이라는 개념이 필요하다. 이 **의존성 주입**(DI, Dependency Injection)을 통해서 모듈 간의 결합을 느슨하게 만들어줄 수 있기 때문이다. (의존성은 종속성과 동일하게 사용되는 용어이다.)
- **의존성 주입**은 메인 모듈에서 하위 모듈들에 직접적으로 의존성을 주는 것이 아니라, 중간에 **의존성 주입자**(depandency injector) 가 투입되어 메인 모듈이 간접적으로 의존성을 주입할 수 있도록 하는 방식을 말한다. 의존성 주입을 통해서 상위 모듈은 하위 모듈에 대한 의존성을 줄일 수 있으며, 이를 ==디커플링이 된다== 라고도 한다.

**의존성 주입의 장점**

> (모듈을 쉽게 교체할 수 있는 구조이기 때문에) 테스팅하기가 보다 쉬워지며, 마이그레이션을 하기에도 좋다. 추상화 레이러를 기반으로 구현체를 넣어주기 때문에 어플리케이션 의존성 방향이 일관되고, 이를 통해서 쉽게 추론할 수 있게 되며 모듈 간의 관계가 명확해진다.

**의존성 주입의 장점**

> 모듈이 분리되므로 클래스의 수가 늘어나 복잡성이 증가한다. 이로 인해 약간의 런타임 패널티가 발생할 수도 있다.

**의존성 주입 원칙**

> 의존성 주입은 의존성 주입 원칙을 지키면서 만들어야 한다.
> 상위 모듈은 하위 모듈에서 어떠한 것도 가져올 수 없으며, 둘 다 추상화에 의존해야 한다. 그리고 추상화는 세부 사항에 의존하지 않는다.

### 1.1.2 팩토리 패턴

- **팩토리 패턴**(factory pattern)은 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**을 말한다. 상속 관계에 있는 두개의 클래스에서 **상위 클래스**가 중요한 **뼈대를 결정**하고 **하위 클래스**에서 객체 생성에 관한 **구체적인 내용을 결정**하는 패턴이다.

- 상위 클래스와 하위 클래스가 분리된 형태이기에 느슨한 결합을 추구하고, 상위 클래스는 뼈대를 결정하기 때문에 이외의 것(인스턴스 생성 방식)에는 신경쓰지 않아도 되기에 더 많은 유연성을 갖게 된다. 상위와 하위의 할일이 분리되어 각각의 로직 또한 별개이기 때문에 **유지 보수성** 또한 **증가**한다.

#### 자바스크립트의 팩토리 패턴

- 자바스크립트에서 팩토리 패턴을 구현할 때는 `new Object()` 를 사용한다.

```js
const num = new Object(42);
const str = new Object("abc");

num.constructor.name; // Number
str.constructor.name; // String
```

- 각각의 전달 사항에 따라 다른 타입의 객체를 생성한다. 즉, 전달받은 값에 따라 별개의 객체를 생성하며 인스턴트 타입 등을 정한다.

#### 클래스 내부의 정적 메소드

> 하위 클래스 내부에서 정적 메소드를 사용하면, 클래스의 인스턴스 없이 호출이 가능하고 메모리를 절약할 수 있다. 또한 개별 인스턴스에 묶이지 않고 클래스 내의 함수를 정의할 수 있다는 장점이 있다.

### 1.1.3 전략 패턴

- **전략 패턴**(strategy pattern)은 **정책 패턴**(policy pattern) 이라고도 한다. 객체의 행위를 변경하고 싶을 때 '직접' 수정하는 대신 **캡슐화한 알고리즘**(==전략==이라고 부른다)을 **컨텍스트** 안에서 바꿔주면서 **상호 교체**가 가능하도록 만드는 패턴을 의미한다.

**컨텍스트**

> 상황, 맥락, 문맥을 의미. 개발자가 어떠한 작업을 완료하는 데 필요한 모든 정보를 일컬음.

#### passport의 전략 패턴

- **passport**는 전략 패턴을 활용한 **Node.js** 에서 인증 모듈을 구현할 때 사용하는 미들웨어 라이브러리이다. 여러 ==전략==을 기반으로 인증할 수 있도록 한다.

### 1.1.4 옵저버 패턴

- **옵저버 패턴**(observer pattern)은 ==주체가 어떤 객체(subject)의 상태 변화를 관찰==하고 **변화**가 있을 때마다 메서드 등을 통해서 옵저버 목록에 있는 ==옵저버들에게 변화를 알려주는== 디자인 패턴이다.
  - 주체 : 객체의 상태 변화를 지켜보는 관찰자.
  - 옵저버 : 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 **추가 변화**가 생기는 객체들을 의미.
- **옵저버 패턴**은 **주체**와 **객체**가 **합쳐진 상태**로 변화를 감지하여, **옵저버**들에게 변화를 알려주는 형태도 있다.
  ex) Twitter는 옵저버 패턴을 사용한다.
- **옵저버 패턴**은 이벤트 기반 시스템이나 MVC(Model-View-Controller) 패턴에 주로 사용된다.

#### 자바스크립트의 옵저버 패턴

- 자바스크립트의 옵저버 패턴은 ==프록시 객체를 통해 구현==할 수도 있다.

**프록시 객체**

- 프록시(proxy) 객체는 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 의미한다.

- 자바스크립트에서 프록시 객체는 두 개의 배개변수를 가진다.
  **target** : 프록시할 대상
  **handler** : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져있는 함수

**프록시 객체를 구현한 JS 코드**

```js
const handler = {
  get: function (target, name) {
    return name === "name" ? `${target.a} ${target.b}` : target[name];
  },
};

const p = new Proxy({ a: "KUNDOL", b: "IS AUMUMU ZANGIN" }, handler);
console.log(p.name); // KUNDOL IS AUMUMU ZANGIN
```

- `p` 라는 변수에 `name` 속성을 선언하지 않았지만, `p.name` 으로 `name` 속성에 접근하려고 할 때, `Proxy` 객체가 그 부분을 가로채 문자열을 만들어서 반환하고 있는 것을 알 수 있다.

**프록시 객체를 이용한 JS 옵저버 패턴**

```js
function createReactiveObject(target, callback) {
  const proxy = new Proxy(target, {
    set(obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop];
        obj[prop] = value;
        callback(`${prop}가 [${prev}] >> [${value}] 로 변경되었습니다. `);
      }
      return true;
    },
  });
  return proxy;
}

const a = {
  형규: "솔로",
};
const b = createReactiveObject(a, console.log);

b.형규 = "솔로";
b.형규 = "커플";
// 형규가 [솔로] >> [커플] 로 변경되었습니다.
```

- 프록시 객체의 `get()` 함수는 속성과 함수에 대한 접근을 가로채고 있다. `has()` 함수는 `in` 연산자의 사용을 가로챈다. `set()` 함수는 속성에 대한 접근을 가로챈다. `set()` 함수를 통해 속성에 대한 접근을 가로채서 '형규' 라는 속성이 '솔로'에서 '커플'로 변경된 것이다.

### 2. 프로그래밍 패러다임

- 프그래밍 패러다임은 간단 말해 ==개발 방법론==이다.
- 패러다임이라는 것은 프로그래밍을 하는 여러가지 스타일 중에 한 가지 방식을 의미한다.
- 어떤 언어들은 특정한 패러다임을 지원하기도 한다. (ex. 자바는 객체지향, 하스켈은 함수형 프로그래밍을 지원 한다.)
- 프로그래밍 패러다임은 크게 선언형, 명령형으로 나뉜다.
  - 선언형 -> 함수형
  - 명령형 -> 1. 객체지향 2. 절차지향

#### 1.2.1 선언형과 함수형 프로그래밍

**선언형 프로그래밍**

- 함수형 프로그래밍은 선언형 프로그래밍의 일종이다. (하위 집합이다.)
- 함수형 프로그래밍은 ==고차 함수== 를 통해 재사용성을 높인 프로그래밍 패러다임이다.
- 자바스크립트에서 함수는 ==일급 객체== 이기 때문에, 객체지향 프로그래밍 보다는 함수형 프로그래밍 방식을 더 선호한다.

**순수 함수**

- 순수 함수는 출력이 입력에만 의존하는 것을 의미한다.

```js
const pure = (a, b) => {
  return a + b;
};
```

**고차함수**

- 고차함수는 함수가 함수를 매개변수로 받아 로직을 생성할 수 있는 것을 의미한다.
- 고차함수를 쓰기 위해서는 ==일급 객체(일급 시민)== 의 특징이 필요하다.

**일급 객체(일급 시민)**

- 변수나 메서드에 함수를 할당할 수 있다.
- 함수 안에 함수를 매개 변수로 담을 수 있다.
- 함수가 함수를 반환할 수 있다.

#### 1.2.2 (명령형) 객체지향 프로그래밍

[드림코딩-객체지향 정리](https://decisive-aftermath-f41.notion.site/4-2-OOP-6ab0ba5bd1fb40d89b2760836531a69a)

- 객체지향 프로그래밍(OOP)은 명령형 프로그래밍의 일종이다.
- 객체지향 프로그래밍은 ==객체들의 집합==으로 프로그래밍의 상호 작용을 표현한다.
- 객체지향 프로그래밍은 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식이다.
- 설계에 많은 시간이 소요되며, 처리 속도가 상대적으로 느리다.

> 객체지향 프로그래밍은 객체들을 컨셉으로 해서 프로그래밍을 해나가는 방식을 말한다. 다양한 프로그래밍 언어로 '객체를 지향' 하는 프로그래밍 스타일을 구현할 수 있으며, 언어마다 어떤 방식, 어떤 문법을 통해서 객체지향을 구현할 수 있는지는 조금씩 다르긴 하나 전반적인 개념과 사용방법 그리고 코딩하는 방식은 크게 차이나지 않는다.

#### 객체지향 프로그래밍의 특징

[드림코딩-객체지향 특징 정리](https://decisive-aftermath-f41.notion.site/4-3-9ee0b3e9d92a4fd79a02d2a1e4856e05)

**캡슐화**

- 서로 관련있는 데이터와 함수를 하나의 한 오브젝트 안에 담아두는 캡슐화를 통해, 외부에서 보일 필요가 없는 데이터를 잘 숨겨놓는다.
- 캡슐화된 상태에서는 외부에서 상태를 '변경' 시킬 수는 있으나, 내부의 상태를 외부에서 설정할 수는 없다.

![[Pasted image 20220516211055.png]]

> 우리는 고양이에게 야 이제 배고파 하라던가 피곤해하라던가 행복해하라는 등의 고양이 내부의 상태를 외부에서 설정할 수 없다. 고양이가 배고프고, 화나고, 행복해하는 감정 상태들은 고양이 내부에서 결정된다. 다만, 외부에서 우리는 고양이를 놀아주고, 먹을 것을 주면서 고양이 내부의 상태를 '변경' 시킬 수는 있다.

**추상화**

- 추상화는 캡슐화와 밀접한 연관이 있다.
- 추상화는 복잡한 시스템으로부터 핵심적인 개념과 기능을 간추려내는 것을 의미한다.
- 추상화는 내부의 복잡한 기능들을 이해할 필요 없이, 외부에서 간단한 인터페이스를 통해 사용할 수 있는 것을 의미한다.

![[Pasted image 20220516211259.png]]

> 우리는 커피머신이 어떻게 동작하는지 우리가 이 커피머신의 내부구조를 다 이해하고 있지 않지만, 기계에서 제공하는 간단한 **버튼**만 누르면 바로 커피를 만들 수 있게 된다.

**상속성**

- 상속성은 상위 클래스의 특징을 하위 클래스가 이어 받아서 재사용하고, 추가-확장하는 것을 의미한다.
- 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요하다.

![[Pasted image 20220516212355.png]]

> **커피머신**이라는 부모 클래스가 정의되어 있다. **커피머신**은 필요한 데이터(data1, data2)와 함수(function)가 함께 들어있으며, 상속을 이용하면 이렇게 잘 만들어진 커피머신의 데이터와 함수를 그대로 상속 받은 뒤 필요한 기능을 더해서 다른 종류의 커피머신(커피브루어, 에스프레소머신)을 만들 수 있게 된다.
>
> 이처럼 상속을 잘 이용하면 한번 정의해둔 클래스를 재사용 할 수 있게 된다. 상속의 관계는 부모 클래스와 자식 클래스로 나눠서 부른다.
>
> **커피머신**을 상속한 또 다른 에스프레소머신은 **커피머신**이라고 말할 수 있다. 또한 **커피머신**을 상속한 다른 클래스인 커피브루어 역시 커피머신이다. 이처럼 상속을 받은 자식 클래스는 부모 클래스라고도 말할 수 있다.

![[Pasted image 20220516212708.png]]

> **animal** 이라는 부모 클래스가 정의되어 있다. 이 클래스는 makeSound 라는 함수를 가진 클래스이다. 그리고 이 함수를 상속한 다른 클래스인 강아지, 고양이, 돼지가 있다. 이런 강아지, 고양이, 돼지 클래스드른 모두 다 **animal** 클래스를 상속했기 때문에 **animal** 이라고도 말할 수 있을 것이다. 그리고 상속을 했기 때문에 다 공통적인 makeSound 라는 함수를 가지고 있을 것이다.

![[Pasted image 20220516212811.png]]

> 브라우저 위에서 쓰이는 DOM 요소 역시 상속을 이용해서 구현되어져 있다. HTMLElement 라는 클래스는 사실 Element라는 클래스를 상속받았기 때문에 HTMLElement 은 Element라고도 말할 수 있게 된다. 또한 이 Element는 Node 라는 것을 상속 받았기 때문에 Node 안에 있는 속성과 함수들을 Element가 사용할 수 있다. 그리고 Node는 바로 EventTarget을 상속 받았기 때문에 역시 EvnetTarget에 있는 이벤트와 관련된 모든 속성과 함수들을 Node 에서도 이용할 수 있게 된다.

이러한 Inheritance상속의 구조를 보면 Document나 Element나 Text 같은 요소들은 전부 EventTarget을 상속하기 때문에 모든 요소들에서 이벤트가 발생할 수 있음을 이해할 수 있다.

**다형성**

- 다형성은 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.
- 다형성은 상속을 통해서 만들어진 클래스들이 어떤 종류인지 상관하지 않아도 공통된 함수를 이용해서 접근하여 호출할 수 있다.
- 다형성에는 오버로딩과 오버라이딩이 있다.

==오버로딩==

- 오버로딩은 같은 이름을 가진 메서드를 여러 개 두는 것을 의미한다.
- 메서드의 타입, 매개변수의 유형, 개수 등으로 같은 이름을 가진 메서드 여러 개를 둘 수 있다.
- 컴파일 중에 발생하는 '**정적**' 다형성이다.

```js
class Person {

	public void eat(String a) {
		System.out.printIn("I eat " + a);
	}
	public void eat(String a, String b) {
		System.out.printIn("I eat " + a + " and " + b);
	}

}

public class CalculateArea {

	public static void main(String[] args) {
		Person a = new Person();
		a.eat("apple");
		a.eat("tomato", "phodo");
	}
}


// I eat apple
// I eat tomato and phodo
```

==오버라이딩==

- 오버라이딩은 주로 메서드 로버라이딩을 말한다.
- 로버라이딩은 상위 클래스로부터 상속받은 메서드를 하위 클래스가 **재정의** 하는 것을 의미한다.
- 런타임 중에 발생하는 '**동적**' 다형성이다.

```js
class Animal {

	public void bark() {
		System.out.printIn("mumu! mumu!");
	}

}

class Dog extends Animal {

	@Override
	public void bark() {
		System.out.printIn("wal!!! wal!!!");
	}
}

public class Main {

	public static void main(String[] args) {
		Dog d = new Dog();
		d.bark();
	}
}


// wal!!! wal!!!
```

- 자식 클래스(`Dog`) 기반으로 부모 클래스(`Animal`)의 메서드(`bark()`)가 재정의된 것을 알 수 있다.

**객체지향 설계 원칙**

- 객체지향 프로그래밍을 설계할 때는 ==SOLID== 원칙을 지켜야 한다.

**SOLID**

- 단일 책임 원칙
  모든 클래스는 하나의 책임만 가져야 한다는 원칙

- 개방-패쇄 원칙
  기존의 코드를 크게 변경하지 않고, 확장을 쉽게 할 수 있어야 한다는 원칙.

- 리스코프 치환 원칙
  부모-자식이라는 계층관계에서 상속이 이루어질 때 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가야 한다는 원칙. 프로그램의 정확성을 유치하고 하위 타입의 인스턴스로 바꿀 수 있어야 한다는 원칙.

- 인터페이스 분리 원칙
  하나의 일반적인 인터페이스보다 구체적인 여러 개의 인스턴스를 만들어야 한다는 원칙

- 의존 역전 원칙
  상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다는 원칙. 변화에 영향받지 않도록 해야한다는 원칙

#### 1.2.3 절차형 프로그래밍

- 계산이 많은 작업에 쓰이는 프로그래밍 패러다임.
- 모듈화가 어렵고 유지보수성이 떨어진다는 단점이 있음.

#### 1.2.4 패러다임의 혼합

- 어떤 프로그래밍 패러다임이 좋은지에 대해서는 말할 수 없다. 왜냐하면 이것은 어디까지나 '스타일'이기 때문이다. 비지니스 로직이나 서비스의 특징을 고려해서 이 프로그래밍 패러다임을 '선택'하는 것이 좋다. 또한 하나의 패러다임을 기반으로 통일하는 것보다 여러 패러다임을 조합하여 상황과 맥락에 따라 각각의 장점만 취하는 것도 좋은 방법일 것이다.

---

### 🧢 **챕터1 <디자인 패턴 & 프로그래밍 패러다임> 퀴즈 2회차** 🧢

### Q1. 라이브러리와 프레임워크의 공통점과 차이점이 무엇인지 설명해보세요.

공통점 : 개발을 할 때 공통적으로 사용되거나 필요한 어떤 기능들을 모듈화한 것을 말한다.
차이점 : 프레임워크는 라이브러리에 비해 규칙에 엄격하고, 라이브러리는 조금 규칙에서 더 자유로운 것이 차이점이다.

집을 만드는 과정을 토대로 예를 들어보자면, 프레임워크(앵귤러)는 이미 집의 구조나 철제들이 완성된 완성품에 더 가깝기 때문에 정해진 골격 안에서 내가 원하는 기능을 구현해야 한다. 반면 리액트와 같은 라이브러리인 경우에는 내가 원하는 재료를 골라서 내 취향과 입맛에 맞게 집을 지을 수 있고, 내가 필요한 기능에 따라서 라이브러리를 골라서 사용할 수 있다는 차이점이 있다.

**리유님 답변**

- 프레임워크는 강제성이 있다. 강제적으로 사용해야만 하는 것들이 있다. 스벨트는 프레임워크이다. 스벨트가 프레임워크이기 때문에 규칙이 정해져있다. 명령된, 정의된, 약속된 것이 존재하고 라이브러리는 강제성이 적다. 자유롭다.

### Q2. 디자인 패턴을 설명해보세요.

> 프로그램을 설계할 때 고려해야 하는 문제들이나 이슈들을 기반으로 이를 해결 할 수 있도록 패턴화한 규칙을 의미한다.

[디자인 패턴 참조](https://rhea31.gitbook.io/blog/development/more/undefined/whatisit)

- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수있는 패턴 규칙을 의미한다. 패턴은 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 아주 중요한 역할을 한다. 즉, **디자인 패턴**이란, 개발자들끼리 협업을 잘할 수 있도록 코드들의 패턴을 짬과 코드의 질, 효율성을 높히는 것이라 부를 수 있다는 것을 알 수 있다

### Q3. 싱글톤 패턴에 대해 설명하고 사용 사례를 얘기해보세요.

> 싱글톤 패턴은 하나의 인스턴스를 만들어 놓고 이 인스턴스를 다른 모듈들이 공유해서 사용하는 것을 말한다. 하나의 인스턴스에 의존해서 사용하기 때문에 인스턴스 생성 비용이 낮지만, 의존성이 높아진다는 단점이 있다.

[싱글톤 패턴 참조](https://rhea31.gitbook.io/blog/development/more/undefined/undefined/singleton)

- 전역 변수를 사용하지 않고 객체를 하나만 생성(한 클래스에 한 객체만 존재하도록 제한)하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴을 의미한다.

### Q4. 의존성 주입(DI)의 목적과 장단점에 대해 설명해보세요.

> 의존성 주입은 싱글톤 패턴의 단점(의존성이 높다.)을 해결하기 위해 등장했다.

- **의존성 주입**은 메인 모듈에서 하위 모듈들에 직접적으로 의존성을 주는 것이 아니라, 중간에 **의존성 주입자**(depandency injector) 가 투입되어 메인 모듈이 간접적으로 의존성을 주입할 수 있도록 하는 방식을 말한다. 의존성 주입을 통해서 상위 모듈은 하위 모듈에 대한 의존성을 줄일 수 있으며, 이를 ==디커플링이 된다== 라고도 한다.-

**리유님 답변**

- 뚝배기에 재료를 넣는 과정(DI)
  - 기존의 싱글톤 패턴의 단점 : 각각의 재료에 대해서 분리했기 때문에 모듈화가 X
  - 의존성 주입을 쓴다는 것 자체가 인터페이스 명세에 맞는 것을 쓴다는 것이기 때문에 코드 양이 길어지고, 관리하기가 힘들다.

**참조**
[Dependency Injection 디자인 패턴](https://juyeop.tistory.com/26)
[(Design Pattern) Dependency Injection 이란?](https://medium.com/@su_bak/design-pattern-dependency-injection-%EC%9D%B4%EB%9E%80-8403c62a225c)
[의존성 주입(Dependency Injection)의 개념](https://mangkyu.tistory.com/150)

### 의존성 주입(DI)을 하는 이유

- 의존성 주입 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 관계를 다이나믹하게 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.

### 의존성 주입의 장점

**1. 코드의 재사용성 증가**

- 만약 특정 객체를 여러 클라이언트에서 의존한다면 각 클라이언트가 특정 객체를 모두 구현할 필요없이 서비스가 이를 한 번만 구현하여 여러 클라이언트에게 의존성을 주입해주어 효율적입니다.

**2. 리펙토링의 과정 수월**

- 특정 객체에 의존성이 존재하는 클라이언트와 특정 객체를 필요로하는 클라이언트에게 간접적으로 의존성을 주입하는 서비스의 모듈이 체계적으로 분리되어 리펙토링 과정에서 조금 더 수월합니다.

**3. 보일로 코드 감소**

- 특정 객체를 필요로하는 클라이언트가 직접적으로 그 객체를 구현하지 않고 주입 받는 형식으로 이루어지기 때문에 필요할 때만 데이터를 전달받아 보일러 코드와 같이 메모리 누수 현상을 막을 수 있습니다.

**4. 프로그램 테스트 용이**

- 프로그램 내의 각 모듈들이 체계적으로 분리되어 Unit Test를 보다 더 쉽게 진행할 수 있습니다.

#### 정리

- 의존성 주입을 사용하면 코드의 재사용성을 높여주고 객체 간의 의존성을 줄이거나 없앨 수 있는 장점이 있는 반면 의존성 주입을 위한 선행작입이 필요하고 코드를 추적하기가 어려워질 수 있다는 단점도 존재합니다.

### Q5. 팩토리 패턴의 개념과 장점을 설명해보세요.

- **팩토리 패턴**(factory pattern)은 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**을 말한다. 상속 관계에 있는 두개의 클래스에서 **상위 클래스**가 중요한 **뼈대를 결정**하고 **하위 클래스**에서 객체 생성에 관한 **구체적인 내용을 결정**하는 패턴이다.

- 상위 클래스와 하위 클래스가 분리된 형태이기에 느슨한 결합을 추구하고, 상위 클래스는 뼈대를 결정하기 때문에 이외의 것(인스턴스 생성 방식)에는 신경쓰지 않아도 되기에 더 많은 유연성을 갖게 된다. 상위와 하위의 할일이 분리되어 각각의 로직 또한 별개이기 때문에 **유지 보수성** 또한 **증가**한다.

### Q6. 자바스크립트에서 프록시 객체의 get(),has(),set() 함수의 기능을 설명해보세요.

- 프록시 객체의 `get()` 함수는 속성과 함수에 대한 접근을 가로챈다.
- 프록시 객체의 `has()` 함수는 `in` 연산자의 사용을 가로챈다.
- 프록시 객체의 `set()` 함수는 속성에 대한 접근을 가로챈다.

> 핑구님 답 : get은 값을 조회, has는 값이 존재하는지 여부를 판단하여 true나 false를 반환, set은 값을 정해주는 메서드입니다. 프록시 객체에서의 역할은 각각 외부의 접근을 가로채는 역할입니다.

### Q7. MVC 패턴을 설명하고 MVVM패턴과의 차이는 무엇인지 설명해보세요.(책에 나온 문제)

- **MVC** 패턴은 어플리케이션의 구성 요소를 모델(Model), 뷰(Vlew), 컨트롤러(Controller)로 구분하여 각각의 구성 요소에만 집중할 수 있도록 한다.
  장점 : 재사용성과 확장성이 용이하다.
  단점 : 어플리케이션이 복잡해질 수록 **모델** 과 **뷰** 의 관계가 복잡해진다.

**리유님 답변**

- M : 비즈니스 로직
- V : 화면 단, 인터페이스 요소
- C : 컨트롤러, 라우팅~

- **MVVM** 패턴은 MVC의 **C** 에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴이다. 뷰모델은 뷰를 더 추상화한 계층이며, 커멘드와 데이터 바인딩을 가지는 것이 특징이다.
  장점 : 양방향 데이터 바인딩을 지원하고, 코드 수정 없이 UI를 재사용할 수 있으며, 단위 테스팅이 쉽다.

**리유님 답변**

- 뷰 모델이라는 친구는 코드에 데이터가 변경이 된다는 것을 미리 계산을 해두는 메서드를 만들고, 이 메서드를 통해서 어떤 데이터가 들어오더라도 고칠 수 있고, 수정이 발생하더라도 양방향 바인딩이 되기 때문에 데이터 관리가 쉬워진다.

### Q8. 객체지향 프로그래밍의 개념과 특징을 설명해보세요.

- 객체지향 프로그래밍은 객체들의 집합으로 프로그램의 상호작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 사용되는 방식을 의미한다. 설계에 많은 시간이 들며, 다른 프로그래밍 패러다임에 비해 처리 속도가 느리다는 단점이 있다.

- 객체지향 프로그래밍의 특징에는 추상화, 캡슐화, 상속성, 다형성 등이 있다.
  - **추상화**는 핵심적인 개념 혹은 기능을 최대한 간추려내는 것을 의미한다.
  - **캡슐화**는 객체의 속성과 메서드를 하나로 묶어서 외부로부터 은닉하는 것을 말한다.
  - **상속성**은 상위 클래스의 특징을 하위 클래스가 이어 받아서 재사용하고 추가/확장하는 것을 말한다. 재사용 및 유지 보수성 측면에서 중요한 특징이다.
  - **다형성**은 메서드나 클래스가 다양한 방법으로 동작하는 것을 말하며, 대푲거으로 오버로딩, 오버라이딩이 있다.

### Q9. 고차 함수를 쓰기 위해 언어가 가져야 할 특징은 무엇이며 그 특징에 대해 설명해보세요.

- 고차 함수를 쓰기 위해서는 해당 언어가 **일급 객체(일급 시민)라는 특징**을 가져야 한다.
- 변수나 메서드에 함수를 할당할 수 있다
- 함수 안에 함수를 매개변수로 담을 수 있다
- 함수가 함수를 반환할 수 있다.

### Q10. SOLID 원칙을 설명해보세요.

- **SOLID**는 객체지향 프로그래밍을 설계할 때 필요한 원칙이다.

- S(단일 책임 원칙) : 클래스는 하나의 책임만 가져야 하는 원칙.
- O(개방 폐쇄 원칙) : 유지 보수 사항이 생긴다면, 코드를 쉽게 확장할 수 있어야 하고, 수정할 때는 닫혀있어야 한다는 원칙. 즉, 기존의 코드를 변경하지 않고 확장을 쉽게 해야 한다는 의미.
- L(리스코프 치환 원칙) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다는 뜻이다. 즉, 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가게 만드는 것을 의미한다.
- I(인터페이스 분리 원칙) : 일반적인 하나의 인터페이스 보다, 구체적인 여러개의 인터페이스를 추구해야 한다는 원칙을 의미한다.
- D(의존 역전 원칙) : 변하기 쉬운 것의 변화에 영향받지 않도록 해야 한다는 원칙을 의미한다. 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립성을 가져야 한다는 뜻이다.

### 피드백

- 질문에 대해서 1분안으로 설명하기
- 그 이상 될 것 같으면 더 설명이 필요하신가요? 라고 되묻기.
- MVVM 패턴에서 뷰 모델은 직접 써본 적은 없지만, vue.js 에서 쓴다고 알고 있고~ MVVM 패턴은 뷰모델을 가지고 있다고 간단하게 특징 설명하기.
