# 챕터 1 정리

디자인 패턴들이 많이 있는데, 면접에서는 이 패턴 중 다 알고 있다는 점에 중점 보다, 이 패턴중 이런걸 써봤는데 장단점이 이러했고 요런걸 만들어봤어요. 하는것이 좋다.
그래도 패턴이라는것을 알고 있으면 개발이나 설계 대화에서 특정한 패턴을 설명해야 부분을 단축할 수 있기 때문에 알아두면 좋다.
그리고 어떤 패턴을 고집해야하는것은 절대 없으며, 어떤 패턴이 미친듯이 좋다는 어디에도 없다. 그리고 코드를 짜다보면 이러한 패턴을 참고하여 클린코드 전략을 짤 수 있다. 자신이 개발한 코드가 덕지덕지하다면 한번 패턴으로 만들어보는것은 어떨까?

## 싱글톤 패턴
패턴 중 가장 일반적으로 많이 쓰고 있으면서도 모르게되는 패턴이 아닐까.
인스턴스를 중복해서 발생하지 않게 하여, 메모리 낭비를 줄이고, 재사용성을 높인 패턴
Single page Application 을 개발할 때 주로 쓰고, DB 커넥션에도 주로 사용한다.
자연스럽게 사용하고 있으므로, 자신이 쓰는 라이브러리나 프레임워크가 싱글톤으로 구현된게 아닌지 한번 살펴보는 것도 좋다.
테스트에 어려움이 있지 확실히 ㅠㅠㅠㅠㅠㅠ 이 인스턴스나 저인스턴스나 공통적인 상태를 가지고 있어서 유효한지 확인하기가 어렵다. 

### DI 적인 부분
- 이부분이 좀 어렵게 다가올 수 있는데 간단하게 더 풀어서 설명해본다.
- 각 모듈별로 각각 나눠서 개발한다.
    - 테스트가 쉬워짐
- 메인 프레임워크에서 (메인엔진 혹은 코어모듈) 각각 나눠저있는 친구들에게 의존성을 주입해서 연결함
    - 이렇게 하면 위에서 말한 각 모듈별로 유연하게 돌아가고
    - 전체 애플리케이션을 돌리지만 의존성은 코어에서 넣어주니 프로그램이 돈다 이거지!!
- 더 쉽게
    - react 를 사용하지 않고 모듈을 독립적으로 개발 함.
    - 메인 코어에서 파일들의 최 상단에 import React from 'react' 를 넣어서 다 묶어줌. 이게 자동.
    - 단점
        - 파일이 쪼개져있어서 죽어남
        - 상 하위 모듈간의 뭐든 가져오면 안 됨.
        - 위배 됨.


## 팩토리 패턴
공장이지 공장!!!
각자의 의존성만을 쭉쭉 주입시켜서 찍어내는 친구를 미리 생성시켜놓고 재료가 들어오면 뾱뾱 만들어주는 패턴

- 보통은 특정 기능을 모아놓는 생성자 집합이라고 봐도 되겠다.
    - 책에서는 각종 커피를 만드는 커피공장을 만들어두고, 미리 각 커피에 대한걸 정의해놓았다.
    - 그리고 그 금액이나, 특수한 재료들을 더 넣어서 맛있는 커피를 생성해준다.


## 전략 패턴
잘 안쓰긴하지.
- `직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴` - 이해한사람?
    - 캡슐화한 알고리즘
        - 공통된 인터페이스 하나를 뚫어놓고 이걸 근간으로 삼는다.
        - 책 예제에서는 PaymentStrategy 로 했는데, 자동차나 비행기나 기차, 배를 만들면 '엔진으로 움직이는 것이니' Movable 같은 인터페이스로 만들 수 있음. 여기에 메서드는 달리는 move() 가 있겠지
    - 여기서 이제 전략 선언해서 합치면 되는데
        - 배: 물위를 달림
        - 기차: 선로를 달림
        - 차: 도로를 달림
        - 뱅기: 하늘을 달림
        이런 전략을 짜고 전략을 설정할 수 있는 메서드를 등록 해 둔다.
    - 마지막으로 만들자
        - const 배 = new 배('짱멋진배','태평양');
        - const 배2 = new 배('통통배','호수'); 
        - const 구린차 = 차('똥차','시골길');
- 어떤 패턴을 사용할지는 뭐 사람의 마음 아니겠나...

## 옵저버 패턴
제법 많이 쓰이는데, SPA를 제작을 한다면 싱글톤을 쓰고, 자신이 만든 데이터 구조에 어떻게 정보를 업데이트해서 화면에 뿌려줄거에요? 라고 설명할 때, 옵저버 패턴을 써서 구현했어요. 라고 말할 수 가 있다.

- 옵저버라는 의미를 그대로 머릿속에 넣고 있어보자. 옵저버는 뭔가! 옵저버는 계속해서 지켜보고 있다 +_+를 의미한다고 보면된다. 
- 책에서 설명을 많이 잘 해둔듯...? 왜 이것만?
- MVC에서 계속 연결해서 보면 된다.

## 프록시 패턴과 프록시 서버
- 계약된 친구와 손잡고 그친구만 허가해두고, 뒤로 샤샥 샤샥 전해주고 돌려주는 방법을 멋지게 설명 해 둠.

## 이터레이터 패턴
- 이것도 이터레이터를 만들었다. 각종 순회하는 친구를 범용으로 만들었다. 를 고급지게 표현 함. 

## 노출 모듈 패턴
나도 요건 패턴으로 존재하는지 몰랐네... 
구현을 이런식으로 하면 되긴 하구나. 타입스크립트 쓰세요 타입스크립트 쓰시고 클래스형태로해서 (아닙니다...)

## MVC 패턴
흔히 쓰는 모델 뷰 컨트롤러 패턴.
각 모델 뷰와 컨트롤러에서는 하는 역할이 나누어져 있다.
- 모델은 컨트롤러를 상호적으로 바라본다. 뷰를 바로 보지 않음. 모델은 정의 하는것들 상수같은것들이나 데이터가 될 수도 있다. 상태를 이곳에서 즉시 접근해서 관리하는 사람들도 있긴 한데... 이 패턴에서는 컨트롤러를 이용하자 
- 뷰 뷰는 컨트롤러에서 처리 된 화면에 대한 정보를 업데이트해서 보여주는 역할을 맡고 있음
- 컨트롤러 모델이랑 뷰에서 하는거 빼고 모든 비지니스 로직을 담아보자.  

## MVP 패턴
- 컨트롤러 친구가 프레젠터로 변경된 패턴
- 일대일관계라고 설명을 해두었는데, 하나의 컨트롤러가 다양한 뷰를 가질 수 있는 위의 패턴보다 강결합이라는거다. 게시판 컨트롤러에 게시판 뷰와 게시판 페이징뷰가 붙을 수 있지만 프레젠터는 각각 다 만들어줘야.

## MVVM 패턴
뷰모델 추상화란 무엇인가! 컨트롤러는 왜 이렇게 다변화 하는것인가? 이녀석이 바로 비지니스 로직을 챙기기 떄문이다.
- 커멘드 : 하나의 액션으로 처리하는 기법이라고 되어 있는데, 하나의 액션이란 무엇인가? 미리 구현되어있는 라이프 사이클에 보면 watch, computed 같은 계산된 속성들이 있다. 이 친구들을 활용한다는 의미다.
    - 뷰.js에는 계산된 속성이라는 computed 같은걸 미리 ViewModel에다가 만들어 놓으면 View 에서 사용할 수 있다.
- 데이터 바인딩 : 특정한 패턴으로 이미 양방향으로 바인딩되어 있어 컨트롤러위치에 있는 뷰 모델에 특정 데이터를 입력하기만 하면 뷰에 반영 됨

----

# 프로그래밍 패러다임
패러다임 말이 좋아서 영어로 패러다임이지 그냥 동향이다.
- 어디까지나 개인적인 의견...

이러한 프로그래밍 패러다임을 이전장에서 설명한 패턴과 접목을 해서 최종적인 코드 형태를 만들어 나간다고 보면 되겠다.

## 함수형 프로그래밍
순수 함수들을 이용해서 결과값을 체인으로 연결해서 처리하는 귀여운친구

## 객체지향 프로그래밍
모든 구성을 객체로 생각하고 구현을 하는 동향으로, 이 동향에 매몰되지 않고 요즘은 다양하고 많은 의견을 수용해서 어떤모듈은 함수형으로 짜고, 어떤건 객체로 짜기도 하는데... 이건 팀바팀이나 프로젝트 바이 프로젝트일듯?
> 1.2.4에서 잘 설명함.

